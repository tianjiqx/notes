# Kubernetes-笔记

**“Kubernetes is the new Linux”**



## 1. 背景

定义：

**Kubernetes是用于自动部署，扩展和管理容器化应用程序的开源系统。**（生产级别的容器编排系统）

起源于google的Borg系统，在社区的参与（创意和实践）下发展壮大。

面向的问题：

- 现代的 Web 服务，用户希望应用程序能够 24/7 全天候使用
- 开发人员希望每天可以多次发布部署新版本的应用程序

容器化改进了这些问题，但是大规模的容器集群运维成为难题，k8s即用来管理容器集群的工具。



针对大规模尺度（星际尺度）

- google每周运行数十亿个容器，在运维团队不扩展情况下，扩展系统的规模。

特性：

- 自动化上线和回滚
  - 对于应用或配置的更改，分步骤的上线，不会停机所有的实例。
  - 出现问题，回滚所做更改。
- 服务发现和负载均衡
  - 应用程序无需修改，即可使用陌生服务
  - k8s为容器提供ip和dns名称，并使各个容器的负载均衡
- 存储编排
  - 自动挂载所选存储系统
    - 本地存储
      - 磁盘
    - 公有云提供商所提供的存储
      - AWS
    - 网络存储系统
      - NFS，Ceph
- 自动装箱
  - 根据资源需求（CPU，RAM）和其他约束自动放置容器，同时避免影响可用性。
  - 高资源需求和低资源需求混合部署，提供资源利用率。
- 水平扩缩
  - 提供命令，UI，或者基于CPU负载自动地对程序进行扩缩
- 自我修复
  - 重新启动失败的容器，自动重试
  - 在节点死亡时替换并重新调度容器
  - 杀死不响应用户定义的健康检查的容器
  - 在容器状态未准备好时，不暴露给客户端
- 秘钥和配置管理
  - Kubernetes允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。
  - 可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，
  - 也无需在堆栈配置中暴露密钥。
- 批量执行
  - 支持定义Jobs，批量执行
- ipv4/ipv6支持
  - 为 Pod 和 Service 分配 IPv4 和 IPv6 地址



服务部署的发展：

物理机部署->虚拟化部署（虚拟机VM）-> 容器化部署（应用共享操作系统，但是有独立的文件系统、CPU、内存、进程空间）

容器化优势：

> - 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。
> - 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的容器镜像构建和部署。
> - 关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。
> - 可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。
> - 跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。
> - 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。
> - 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
> - 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。
> - 资源隔离：可预测的应用程序性能。
> - 资源利用：高效率和高密度。（无VM中间开销）



Kubernetes非传统意义上的编排系统，实际上它消除了编排的需要。

编排：执行A，再执行B，再执行C。

Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 



## 2.架构

![](k8s笔记图片/components-of-kubernetes.svg)

一个 Kubernetes 集群由一组被称作**节点**的机器（可以是虚拟机）组成。

运行 Kubernetes 所管理的容器化应用，是工作节点（至少一个工作节点）。

应用以**Pod**形式部署，一个Pod代表一个容器。

**K8S的架构：**

- 包含一系列组件的控制平面(控制面板)Control Plane
  - 用于管理集群的工作节点和Pod
    - 调度，检查和响应集群事件
  - 可以全部运行在单个master节点，也可以复制，以支持高可用的集群部署
    - 支持自托管
      - 运行在K8S集群本身上
  - 管理节点
    - 一般为了避免业务应用的负载影响，不再作为工作节点
- 节点代理kubelet（主要的节点组件）
  - 工作节点

**控制平面Control Plane：**

- **kube-apiserver** API服务器
  - 负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。
    - 用户请求及其他系统组件与集群交互的唯一入口
  - 查询和操纵 Kubernetes API 中对象（例如：Pod、Namespace、ConfigMap 和 Event）的状态。
    - 提供etcd的封装接口API
    - 集群访问控制
      - 客户端身份验证（Authentication）和授权（Authorization）
      - 资源准入控制（Admission Control）
  - 无状态，可横向扩展
    - 通过Haproxy或负载均衡器 进行协同工作
- etcd

  - etcd 是兼具一致性和高可用性的键值数据库
  - 保存 Kubernetes 所有集群数据
    - Node、Service、Pod 的状态和元数据，以及配置数据等
- **kube-scheduler**
- 监视新创建的、未指定运行节点的Pods（用户要求运行的一组容器），选择节点让Pod在上面运行
- **kube-controller-manager**
  - 统一管理各个控制器的进程
  - 控制器
    - 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应
    - 任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成
    - 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)
    - 服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌
- cloud-controller-manager
  - 云平台交互控制器管理
  - 控制器
    - 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除
    - 路由控制器（Route Controller）: 用于在底层云基础架构中设置路由
    - 服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器

**节点代理组件：**

- **kubelet**

  - 节点的代理
  - 容器执行层，Pod和Node API的主要实现者
    - 接收PodSpecs，确保这些PodSpecs中描述的容器处于运行状态且健康。
    - 负责启动容器的守护进程
      - 启动时，向API Server 处创建一个Node 对象来注册自身的节点信息
- kube-proxy
- 网络代理
- Container Runtime
  - 负责运行容器。
  - 支持
    - docker
    - containerd
    - DRI-O
    - 实现Kubernetes CRI 容器运行环境接口的

## 3.组件详细





## 4.部署应用





## 5.设计哲学

### 5.1 对象的通用设计原则

- Kubernetes 将业务模型化，这些对象的操作都以API 的形式发布出来
  - 因此其所有API 设计都是声明式的
- 控制器的行为应该是可重入和幂等
  - 通过幂等的控制器使得系统一致朝用户期望状态努力，且结果稳定
- 所有对象应该是互补和可组合的，而不是简单的封装
  - 通过组合关系构建的系统
- API 操作复杂度应该与对象数量成线性或接近线性比例
  - 系统的规模扩展性
- API 对象状态不能依赖于网络连接状态
- 尽量避免让操作机制依赖于全局状态



### 5.2 模型设计



### 5.3 控制器模式







## REF

- [kubernetes 官网](https://kubernetes.io/)
- [K8S 官方中文文档](https://kubernetes.io/zh/docs/concepts/)
- [github 社区](https://github.com/kubernetes/community.git) 架构、设计方案
- [Kubernetes生产化实践之路-孟凡杰](https://weread.qq.com/web/reader/cbe32c6072226556cbea464kc81322c012c81e728d9d180) 2020
- Kubernetes in Action

