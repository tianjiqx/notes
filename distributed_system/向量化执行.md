# 向量化执行

## 1. 概念

**Vectorized Execution** 向量化执行：

- 最早使用在monetDB， 和商业版本VectorWise；Quickstep
- 与火山式迭代模型一样，矢量化使用基于**拉**的迭代，但是每次next调用都会获取一个元组块而不是一个元组，这会分摊迭代器调用开销
  - 解释执行
- 在实际的查询处理过程中，往往会在一个或多个类型具体列上执行原语操作（一批，按列执行），例如计算一个integer vector的hash值



**Compiled / data-centric code generation  execution** 编译执行、代码生成:

- HyPer开创，支持的系统Spark，Peloton
- 每个关系运算符实现基于**推送**的接口（produce和consume）
  - produce和consume不是直接处理元组，而是为给定查询生成代码
  - 类似，深度遍历查询计划树，在第一次访问时调用produce，在处理完所有子项后在上次访问时使用consume
- 生成的代码具体化用于查询的特定数据类型，并将非阻塞关系运算符管道中的所有运算符融合到单个（可能是嵌套的）循环中。
  - 然后将该生成的代码编译为有效的机器代码（例如，LLVM）
    - 预先编译





## 2. 原理

### 2.1 Vectorized Execution



### 2.2 Compiled Execution





### 2.3 Vectorized vs Compiled 

OLAP性能方面

- **计算**：编译执行更擅长，将数据保存在寄存器中，需要执行的指令更少
- **并行数据访问**：向量化执行在生成并行缓存未命中方面稍好一些，在访问大型哈希表以进行聚合或连接的内存绑定查询中具有一些优势
- **SIMD**：收益很小，因为大多数操作都受内存访问成本的支配
- **并行化**：矢量化引擎和基于编译的引擎都可以在多核 CPU 上很好地扩展
- **硬件平台**：不占主导地位

其他

- 编译
  - OLTP，可以创建快速存储过程
  - 语言支持，可以无缝集成用不同语言编写的代码
- 向量化
  - 编译时间，原语是预编译的
  - profiling分析，运行时可以归属于原语
  - 适应性，执行原语可以mid-fligh（飞行途中？）交换



简单总结：向量化和编译执行，两种执行引擎性能差异一般不大，基于编译的引擎在计算量大的查询中具有优势，而向量化引擎更擅长隐藏缓存未命中延迟，例如hash连接。



## 3.实现





## REF





扩展材料：

- [十分钟成为 Contributor 系列 | TiDB 向量化表达式活动第二弹](https://zhuanlan.zhihu.com/p/85553472) 
- [[面向guard编程系列] 2. 一元guard的使用： 一个避免静态代码爆炸的C++ idiom，用于OLAP向量化执行引擎的开发](https://zhuanlan.zhihu.com/p/338241036) 
- [数据库计算引擎的优化技术：向量化执行与代码生成](https://zhuanlan.zhihu.com/p/100933389) 
- [PolarDB-X 向量化引擎的类型绑定与代码生成](https://zhuanlan.zhihu.com/p/357520668) 
- [每次都需要解释大量指令？使用 PolarDB-X 向量化引擎](https://zhuanlan.zhihu.com/p/354572485) 
- [cockroachdb:how-we-built-a-vectorized-execution-engine](https://www.cockroachlabs.com/blog/how-we-built-a-vectorized-execution-engine/)
  - 底层存储是kv，非列式，OLTP数据库
  - 在磁盘读取行后，转换为批的列存数据格式，再输入到向量化执行引擎
  - 使用代码生成来减轻向量化执行引擎的维护负担
    - 向量化执行后，分析性能瓶颈在类型转换，类型断言开销上，因此改进是通过代码生成具体类型（不手写重复代码，使用模板，go不支持泛型），提升2倍。（代码量膨胀。rust零成本抽象呢，编译后，知道使用具体的类型，某些方面可能更容易达到高性能，而无需代码生成？宏？）
    - 批处理+模板化代码，比原来提升5.5
    - 进一步优化，多层循环，更改循环顺序，影响
      - 分支预测
      - 流水线
    - 最终提升20倍。基准测试cpu时间提升70倍，tpch测试提升4倍（磁盘时间占比最大，降低了整体的加速比）
  - (该文章包含golang pprof 分析过程)

- [slides: Vectorized Query Execution in Apache Spark at Facebook](https://databricks.com/session/vectorized-query-execution-in-apache-spark-at-facebook) 2019



论文：

- [MonetDB/X100: Hyper-Pipelining Query Execution](http://cidrdb.org/cidr2005/papers/P19.pdf)
- [Vectorization vs. Compilation in Query Execution](https://15721.courses.cs.cmu.edu/spring2016/papers/p5-sompolski.pdf)
- [Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask](https://www.vldb.org/pvldb/vol11/p2209-kersten.pdf)
- [Efficiently Compiling Efficient Query Plans for Modern Hardware](https://15721.courses.cs.cmu.edu/spring2019/papers/19-compilation/p539-neumann.pdf)



相关课程：

- [MIT 6.172: Performance Engineering of Software Systems (Fall 2018)](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-172-performance-engineering-of-software-systems-fall-2018)
  - [【MIT公开课】6.172 软件性能工程 · 2018年秋](https://www.bilibili.com/video/BV1wA411h7N7/) B站



